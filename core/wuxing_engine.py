from lunar_python import Lunar, Solar

class WuXingEngine:
    # ==========================================
    # PARTICLE STANDARD MODEL V4.0 (Shell-Core)
    # ==========================================
    
    # Branch (Shell) Properties:
    # Spin: 1 (Clockwise/Yang), -1 (Counter-Clockwise/Yin)
    # Color: Visual representation of the Shell
    
    BRANCH_SHELL_MAP = {
        "子": {"energy": "Water", "spin": 1,  "color": "#3333FF", "opacity": 0.4}, # Rat (Yang)
        "丑": {"energy": "Earth", "spin": -1, "color": "#8B4513", "opacity": 0.6}, # Ox (Yin)
        "寅": {"energy": "Wood",  "spin": 1,  "color": "#00FF00", "opacity": 0.4},
        "卯": {"energy": "Wood",  "spin": -1, "color": "#00AA00", "opacity": 0.5},
        "辰": {"energy": "Earth", "spin": 1,  "color": "#A0522D", "opacity": 0.6},
        "巳": {"energy": "Fire",  "spin": -1, "color": "#FF4444", "opacity": 0.4},
        "午": {"energy": "Fire",  "spin": 1,  "color": "#FF0000", "opacity": 0.4},
        "未": {"energy": "Earth", "spin": -1, "color": "#D2691E", "opacity": 0.6},
        "申": {"energy": "Metal", "spin": 1,  "color": "#C0C0C0", "opacity": 0.7}, # Monkey (Yang)
        "酉": {"energy": "Metal", "spin": -1, "color": "#FFFFFF", "opacity": 0.7},
        "戌": {"energy": "Earth", "spin": 1,  "color": "#B8860B", "opacity": 0.6},
        "亥": {"energy": "Water", "spin": -1, "color": "#00008B", "opacity": 0.4}
    }

    # Core Composition (Hidden Stems):
    # Ratios represent the mass distribution of the core.
    HIDDEN_STEMS_MAP = {
        "子": {"癸": 1.0},
        "丑": {"己": 0.6, "癸": 0.3, "辛": 0.1},
        "寅": {"甲": 0.6, "丙": 0.3, "戊": 0.1},
        "卯": {"乙": 1.0},
        "辰": {"戊": 0.6, "乙": 0.3, "癸": 0.1},
        "巳": {"丙": 0.6, "戊": 0.3, "庚": 0.1},
        "午": {"丁": 0.7, "己": 0.3},
        "未": {"己": 0.6, "丁": 0.3, "乙": 0.1},
        "申": {"庚": 0.6, "壬": 0.3, "戊": 0.1},
        "酉": {"辛": 1.0},
        "戌": {"戊": 0.6, "辛": 0.3, "丁": 0.1},
        "亥": {"壬": 0.7, "甲": 0.3}
    }

    # 2. Base Weights for Pillar Positions (The "Place" weights)
    # Theory: Month Branch is strongest (Season/De Ling). Day Branch is next (Spouse Palace).
    POSITION_WEIGHTS = {
        "year_stem": 10, "year_branch": 15,
        "month_stem": 12, "month_branch": 40, # Month Branch commands the season
        "day_stem": 0,    "day_branch": 20, # Day Stem is "Self" (reference point, weight handled separately)
        "hour_stem": 12,  "hour_branch": 15
    }

    WU_XING_MAP = {
        "甲": "Wood", "乙": "Wood",
        "丙": "Fire", "丁": "Fire",
        "戊": "Earth",  "己": "Earth",
        "庚": "Metal", "辛": "Metal",
        "壬": "Water", "癸": "Water"
    }
    
    RELATIONSHIPS = {
        "Sheng": {"Wood": "Fire", "Fire": "Earth", "Earth": "Metal", "Metal": "Water", "Water": "Wood"}, # Generates
        "Ke":    {"Wood": "Earth", "Earth": "Water", "Water": "Fire", "Fire": "Metal", "Metal": "Wood"}  # Controls
    }

    def get_relationship(self, e1, e2):
        """
        Returns relationship of E1 relative to E2.
        e.g. if E1 Generates E2, return 'Generates'.
        """
        if e1 == e2: return "Same"
        if self.RELATIONSHIPS["Sheng"].get(e1) == e2: return "Generates"
        if self.RELATIONSHIPS["Ke"].get(e1) == e2: return "Controls"
        if self.RELATIONSHIPS["Sheng"].get(e2) == e1: return "Generated by"
        if self.RELATIONSHIPS["Ke"].get(e2) == e1: return "Controlled by"
        return "Unknown"

    def __init__(self, chart):
        """
        chart: Dictionary structure from BaziCalculator.get_chart()
        """
        self.chart = chart
        self.scores = {"Wood": 0, "Fire": 0, "Earth": 0, "Metal": 0, "Water": 0, "Unknown": 0}
        self.day_master = chart['day']['stem']
        self.day_master_element = self.get_wuxing(self.day_master)

    def get_wuxing(self, char):
        return self.WU_XING_MAP.get(char, "Unknown")
    
    def get_particle_info(self, branch_char):
        """
        Returns the V4.0 Particle Model data (Shell + Core) for a given branch.
        """
        shell = self.BRANCH_SHELL_MAP.get(branch_char, {})
        core = self.HIDDEN_STEMS_MAP.get(branch_char, {})
        return {
            "shell": shell,
            "core": core
        }

    def calculate_strength(self):
        # Reset scores
        self.scores = {k: 0 for k in self.scores}

        # 1. Process Stems (Top row)
        for pillar, weight in [("year", 10), ("month", 12), ("hour", 12)]: # Skip Day Stem
            stem = self.chart[pillar]['stem']
            element = self.get_wuxing(stem)
            if element in self.scores:
                self.scores[element] += weight

        # 2. Process Branches (Bottom row, with Hidden Stems)
        for pillar in ["year", "month", "day", "hour"]:
            branch = self.chart[pillar]['branch']
            weight_key = f"{pillar}_branch"
            total_pillar_weight = self.POSITION_WEIGHTS.get(weight_key, 15)
            
            # Get hidden stems distribution
            hiddens = self.HIDDEN_STEMS_MAP.get(branch, {})
            
            for stem_char, ratio in hiddens.items():
                element = self.get_wuxing(stem_char)
                if element in self.scores:
                     # e.g. Month Branch (40) * Ratio (0.6) = 24 points to Main Qi
                    self.scores[element] += total_pillar_weight * ratio

        # 3. Calculate Day Master Status
        # Comparison: (Self + Generating) vs (Discharging + Controlling)
        self_score = self.scores[self.day_master_element]
        
        # Add "Day Master" constant base score? Usually we consider the environment.
        # Let's say Day Stem itself has intrinsic presence, maybe add theoretical 10 points usually excluded.
        self_score += 10 
        self.scores[self.day_master_element] = self_score # Update global score

        mother_elements = [k for k, v in self.RELATIONSHIPS["Sheng"].items() if v == self.day_master_element]
        if mother_elements:
            mother_element = mother_elements[0]
            mother_score = self.scores[mother_element]
        else:
            mother_score = 0

        strong_side = self_score + mother_score
        total_score = sum(self.scores.values())
        weak_side = total_score - strong_side
        
        # Strength threshold: usually ~40-50% depending on sect. Let's use 50% for neutral.
        # But Month Command is huge. If Self is born in Season, usually Strong.
        
        is_strong = strong_side >= (total_score * 0.45) # Slight bias to Weak if not commanding season

        return {
            "scores": self.scores,
            "total": total_score,
            "day_master": {
                "element": self.day_master_element,
                "score": self_score,
                "status": "Strong (Shen Qiang)" if is_strong else "Weak (Shen Ruo)",
                "percentage": (self_score / total_score) * 100 if total_score > 0 else 0
            },
            "strong_side_pct": (strong_side / total_score) * 100 if total_score > 0 else 0
        }

    def analyze_flow(self):
        """
        Analyze flow: Year -> Month -> Day -> Hour
        """
        flow = []
        pillars = ["year", "month", "day", "hour"]
        
        # Simple analysis of Stem Flow
        for i in range(len(pillars) - 1):
            curr_p = pillars[i]
            next_p = pillars[i+1]
            
            curr_elem = self.get_wuxing(self.chart[curr_p]['stem'])
            next_elem = self.get_wuxing(self.chart[next_p]['stem'])
            
            relation = "Neutral"
            if self.RELATIONSHIPS["Sheng"].get(curr_elem) == next_elem:
                relation = "Sheng (Generate)"
            elif self.RELATIONSHIPS["Ke"].get(curr_elem) == next_elem:
                relation = "Ke (Control)"
            elif self.RELATIONSHIPS["Sheng"].get(next_elem) == curr_elem:
                relation = "Being Generated (Backward)"
            elif self.RELATIONSHIPS["Ke"].get(next_elem) == curr_elem:
                relation = "Being Controlled (Backward)"
                
            flow.append(f"{curr_p.capitalize()} ({curr_elem}) -> {next_p.capitalize()} ({next_elem}): {relation}")
            
        return flow

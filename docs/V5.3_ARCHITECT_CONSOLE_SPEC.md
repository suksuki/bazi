
# Architect Console (V5.3) - UX Data Flow Specification
# Project: Antigravity "God Mode" Interface

## Overview
The Architect Console is a real-time reactive interface that exposes the internal processing layers (L0-L2) of the Quantum Bazi Engine via Streamlit using Session State management.

## Component: State Manager (The Brain)
All Panels subscribe to a central `st.session_state.quantum_context`.
Structure:
```python
st.session_state.quantum_context = {
    "params": {
         "base_weight": 0.5,
         "entropy_penalty": 0.3,
         "enable_phase_locking": True,
         "apply_classic_rules": True
    },
    "simulation": {
         "injected_pillar": None # e.g., '‰∏ôÂçà'
    },
    "results": {
        "l0_spectrum": {},
        "l1_spectrum": {},
        "l2_spectrum": {},
        "triggered_rules": []
    }
}
```

## Data Flow Pipeline

### 1. Trigger (User Action)
**Event**: User moves `Collision Entropy` slider in **Panel 2 (Tuner)**.
- **Action**: Update `st.session_state.quantum_context['params']['entropy_penalty']`.
- **Signal**: `st.rerun()` is triggered automatically by Streamlit widget change.

### 2. Processing (The Engine)
On rerun, the main script calls `FluxEngine.compute_energy_state()` but passes the *Context Params*.

```python
# Pseudo-code logic in main.py
params = st.session_state.quantum_context['params']
engine = FluxEngine(chart)
engine.set_hyperparameters(params) # New method to inject tuner values

if st.session_state.quantum_context['simulation']['injected_pillar']:
    # Inject Sandbox Element
    engine.add_external_pillar(...)

# Compute returns intermediate states now (Trace Mode)
trace = engine.compute_with_trace() 
```

### 3. Rendering (The Panels)

#### Panel 1: Layer Visualizer
- **Input**: `trace['l0']`, `trace['l1']`, `trace['l2']`.
- **Logic**:
  - Draws a **Sankey Diagram** (Plotly):
    - Left Node: `Month Command (L0)` -> Flow Width = Base Energy.
    - Mid Node: `Phase Lock (L1)` -> Flow converges if "Si-You-Chou" enabled.
    - Right Node: `Final Output (L2)` -> Adjusted by Rules.
  - **Dynamic Lines**: If `Enable_Phase_Locking` is OFF (from Panel 2), the flow lines diverge (no convergence), visually proving the effect.

#### Panel 3: Simulation Sandbox
- **Input**: `trace['final_spectrum']`.
- **Logic**:
  - **Heatmap**: Renders a 5x1 grid color-coded by Energy.
  - **Delta Calc**: Compares `trace['final']` with `st.session_state.last_stable_result`.
  - **Alert System**:
    ```python
    if trace['final']['Water'] < 5.0 and trace['final']['Fire'] > 100:
        st.toast("üî• ALERT: Water Vaporized! (Boiling Point Reached)", icon="‚ö†Ô∏è")
    ```

## Implementation Strategy
1.  **Refactor `FluxEngine`**: Add `set_hyperparameters()` and make `compute()` return a Trace Object (Dict with L0/L1/L2 snapshots).
2.  **Create `ArchitectDashboard.py`**: A new page in `ui/pages/` dedicated to this view.
3.  **UI Components**: Use `st.slider`, `st.toggle`, and `plotly.graph_objects.Sankey`.

This flow ensures that **Parameter Tuning (P2)** instantly reshapes the **Logic Path (P1)** and drives the **Risk Outcomes (P3)**.

# Phase 2 后置补偿算法 Review

## 问题描述

F1 三合水案例失败：
- 量子纠缠后能量：190.48
- 传播后能量：256.84
- 能量比率：1.348（预期：2.0）
- 误差：32.6%

## 后置补偿逻辑分析

### 1. 后置补偿的两个位置

#### 位置1：传播循环中的扩展保护（645-715行）
- **作用域**：`H_new`（传播过程中的新能量）
- **条件**：`not is_in_combo`（不在合局中的节点）
- **目的**：对同元素节点（如天干）也应用后置补偿
- **应用时机**：在传播循环内部，每次迭代后

#### 位置2：传播循环后的后置补偿（1028-1126行）
- **作用域**：`H`（最终能量）
- **条件**：`is_in_combo`（在合局中的节点）
- **目的**：确保合局节点达到预期的bonus倍率
- **应用时机**：传播循环结束后，最终处理

### 2. 问题分析

#### 问题1：在合局中的节点后置补偿使用了错误的bonus值

**代码位置**：984-991行
```python
elif 'TRINE' in match_upper or '三合' in match:
    combo_type = 'three_harmony'
    three_harmony_config = branch_events.get('threeHarmony', {})
    if isinstance(three_harmony_config, dict):
        # [V9.6 继续优化] F1案例预期比率2.0，当前2.312，需要进一步降低
        combo_bonus = three_harmony_config.get('bonus', 1.55)  # ❌ 硬编码 1.55
    else:
        combo_bonus = 1.55  # ❌ 硬编码 1.55
```

**问题**：
- 硬编码了 `1.55` 作为默认值，而不是使用配置中的 `2.0`
- 即使配置中有 `threeHarmony.bonus = 2.0`，也会被硬编码的 `1.55` 覆盖
- 导致后置补偿（1118-1126行）使用了错误的倍率

**后置补偿逻辑**（1118-1126行）：
```python
else:
    # 地支合局：总是应用bonus（地支合局通常都会合化成功）
    if combo_bonus > 1.0:
        expected_min = h0_val * combo_bonus  # ❌ 使用了错误的 combo_bonus (1.55)
        if current_val < expected_min:
            H[i] = expected_min
```

**实际效果**：
- 申节点：12.71 * 1.55 = 19.70（实际：16.99，未达到）
- 子节点：43.39 * 1.55 = 67.25（实际：46.13，未达到）
- 辰节点：18.92 * 1.55 = 29.33（实际：22.85，未达到）

#### 问题2：扩展保护逻辑可能没有正确匹配

**代码位置**：649-715行
```python
if not is_in_combo and hasattr(self.engine, '_quantum_entanglement_debug'):
    # 检查是否有合局，且当前节点与合局元素相同
    for match in detected_matches:
        # 提取合局元素
        if 'water' in match.lower() or '水' in match:
            combo_element = 'water'
        # ...
        # 如果当前节点与合局元素相同，也要应用后置补偿
        if combo_element and node_i.element == combo_element and combo_bonus_from_match > 1.0:
            expected_min = h0_val * combo_bonus_from_match
            if current_val < expected_min:
                H_new[i] = expected_min
```

**问题**：
- 扩展保护在 `H_new` 上应用，但后续可能被其他逻辑覆盖
- 匹配逻辑依赖字符串匹配（`'water' in match.lower()`），可能不够精确

**实际效果**：
- 壬节点（天干，不在合局）：应该通过扩展保护达到 2.0 倍率
- 但实际：52.62 * 2.0 = 105.24（实际：78.93，未达到）

### 3. 根本原因

1. **硬编码的bonus值**：984-991行硬编码了 `1.55`，而不是使用配置中的 `2.0`
2. **后置补偿时机**：扩展保护在 `H_new` 上应用，但可能被后续逻辑覆盖
3. **匹配逻辑**：扩展保护的匹配可能不够精确

### 4. 解决方案建议

#### 方案1：修复硬编码的bonus值（推荐）
- 移除硬编码的 `1.55`，使用配置中的 `threeHarmony.bonus`
- 确保后置补偿使用正确的倍率

#### 方案2：统一后置补偿逻辑
- 将扩展保护和后置补偿合并到一个位置
- 在传播循环结束后统一应用，确保所有节点都达到预期倍率

#### 方案3：改进匹配逻辑
- 使用更精确的匹配方式（如解析合局类型和元素）
- 确保所有同元素节点都能被正确识别和应用补偿

## 调试输出分析

```
检测到的合局: ['ThreeHarmony: 子-申-辰 (water)', ...]

水节点能量分析:
  ❌ 壬 (stem, 不在合局): 52.62 -> 78.93 (预期: 105.24)
  ❌ 申 (branch, 在合局): 12.71 -> 16.99 (预期: 25.42)
  ❌ 壬 (stem, 不在合局): 14.28 -> 21.43 (预期: 28.57)
  ❌ 子 (branch, 在合局): 43.39 -> 46.13 (预期: 86.78)
  ❌ 壬 (stem, 不在合局): 13.90 -> 20.86 (预期: 27.81)
  ❌ 辰 (branch, 在合局): 18.92 -> 22.85 (预期: 37.84)
```

**观察**：
1. 所有节点都没有达到预期的 2.0 倍率
2. 在合局中的节点（申、子、辰）使用了错误的倍率（1.55）
3. 不在合局中的节点（壬）扩展保护也没有生效

## 结论

**核心问题**：984-991行硬编码了 `1.55` 作为三合局的bonus，导致后置补偿使用了错误的倍率。

**修复建议**：
1. 移除硬编码的 `1.55`，使用配置中的 `threeHarmony.bonus`
2. 确保后置补偿逻辑使用正确的倍率值
3. 验证扩展保护逻辑是否正确应用到所有同元素节点


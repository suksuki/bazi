# Cursor 编码规则与架构约束

## 🏛️ MVC 架构约束 (MVC Architecture Constraints)

### 强制要求 (Mandatory Requirements)

1. **严格分层架构**
   - **View 层** (`ui/pages/`, `ui/components/`): 
     - ✅ 只能调用 Controller 的方法
     - ❌ 禁止直接调用 Engine、Model 或 Service
     - ✅ 使用 `BaziController` 或 `WealthVerificationController` 作为唯一数据源
   
   - **Controller 层** (`controllers/`):
     - ✅ 负责协调 Model 和 View 之间的交互
     - ✅ 封装业务逻辑，不包含 UI 代码
     - ✅ 提供统一的 API 接口
     - ❌ 禁止直接操作数据库或文件系统（通过 Model 层）
   
   - **Model 层** (`core/models/`):
     - ✅ 负责数据结构和持久化
     - ✅ 提供 CRUD 操作
     - ❌ 禁止包含业务逻辑（业务逻辑在 Controller）
     - ❌ 禁止直接访问 UI 组件

2. **导入规范 (Import Rules)**
   ```python
   # ✅ 正确：View 导入 Controller
   from controllers.bazi_controller import BaziController
   from controllers.wealth_verification_controller import WealthVerificationController
   
   # ❌ 错误：View 直接导入 Engine
   from core.engine_graph import GraphNetworkEngine  # 禁止！
   from core.engine_v88 import EngineV88  # 禁止！
   
   # ✅ 正确：Controller 导入 Model
   from core.models.wealth_case_model import WealthCaseModel
   
   # ❌ 错误：Controller 直接操作文件
   import json  # 应该通过 Model 层
   ```

3. **财富验证功能架构**
   - View: `ui/pages/wealth_verification.py`
   - Controller: `controllers/wealth_verification_controller.py`
   - Model: `core/models/wealth_case_model.py`
   - 数据流: View → Controller → Model → Engine

## 📁 目录结构规范 (Directory Structure)

```
bazi_predict/
├── controllers/          # Controller 层（业务逻辑协调）
│   ├── bazi_controller.py
│   └── wealth_verification_controller.py
├── core/
│   ├── models/          # Model 层（数据模型和持久化）
│   │   └── wealth_case_model.py
│   ├── engine_*.py      # Engine 层（核心计算引擎）
│   └── ...
├── ui/
│   ├── pages/           # View 层（页面组件）
│   │   ├── prediction_dashboard.py
│   │   └── wealth_verification.py
│   └── components/      # View 层（可复用组件）
└── scripts/             # 工具脚本（可以混合使用，但新功能优先 MVC）
```

## 🔧 代码组织规则 (Code Organization Rules)

### Controller 设计模式

1. **单一职责原则**
   - 每个 Controller 只负责一个业务领域
   - `BaziController`: 八字排盘和预测
   - `WealthVerificationController`: 财富验证

2. **Lazy Initialization**
   ```python
   class BaziController:
       def __init__(self):
           self._engine = None  # 延迟初始化
       
       @property
       def engine(self):
           if self._engine is None:
               self._engine = GraphNetworkEngine()
           return self._engine
   ```

3. **状态管理**
   - Controller 维护用户输入状态
   - 使用缓存避免重复计算
   - 输入变更时自动失效缓存

### Model 设计模式

1. **数据类定义**
   ```python
   from dataclasses import dataclass
   
   @dataclass
   class WealthEvent:
       year: int
       ganzhi: str
       dayun: str
       real_magnitude: float
       desc: str
   ```

2. **持久化封装**
   - 所有文件 I/O 操作在 Model 层
   - 提供统一的 CRUD 接口
   - 错误处理在 Model 层完成

### View 设计模式

1. **纯展示逻辑**
   - View 只负责渲染和用户交互
   - 不包含业务逻辑判断
   - 通过 Controller 获取所有数据

2. **组件复用**
   - 可复用组件放在 `ui/components/`
   - 页面特定组件放在 `ui/pages/`

## 📝 命名规范 (Naming Conventions)

### 文件命名
- Controller: `*_controller.py` (如 `bazi_controller.py`)
- Model: `*_model.py` (如 `wealth_case_model.py`)
- View: 描述性名称 (如 `wealth_verification.py`)

### 类命名
- Controller: `*Controller` (如 `BaziController`)
- Model: `*Model` (如 `WealthCaseModel`)
- Data Class: `*Case`, `*Event` (如 `WealthCase`, `WealthEvent`)

### 方法命名
- Controller 公共方法: 动词开头 (如 `get_chart()`, `verify_case()`)
- Model 方法: CRUD 操作 (如 `load_all_cases()`, `save_case()`)
- 私有方法: 下划线前缀 (如 `_load_config()`)

## 🚫 禁止模式 (Anti-Patterns)

### ❌ 禁止在 View 中直接调用 Engine
```python
# ❌ 错误示例
from core.engine_graph import GraphNetworkEngine
engine = GraphNetworkEngine()
result = engine.calculate_wealth_index(...)

# ✅ 正确示例
from controllers.wealth_verification_controller import WealthVerificationController
controller = WealthVerificationController()
results = controller.verify_case(case)
```

### ❌ 禁止在 Controller 中直接操作文件
```python
# ❌ 错误示例
import json
with open('data/cases.json', 'r') as f:
    data = json.load(f)

# ✅ 正确示例
from core.models.wealth_case_model import WealthCaseModel
model = WealthCaseModel()
cases = model.load_all_cases()
```

### ❌ 禁止在 Model 中包含业务逻辑
```python
# ❌ 错误示例
class WealthCaseModel:
    def calculate_wealth(self, case):
        # 业务逻辑应该在 Controller
        result = engine.calculate_wealth_index(...)

# ✅ 正确示例
class WealthCaseModel:
    def load_all_cases(self):
        # 只负责数据加载
        return cases
```

## ✅ 最佳实践 (Best Practices)

1. **错误处理**
   - Controller 层捕获异常并返回错误信息
   - View 层显示用户友好的错误消息
   - Model 层记录详细错误日志

2. **类型提示**
   ```python
   from typing import List, Dict, Optional
   
   def verify_case(self, case: WealthCase) -> List[Dict[str, Any]]:
       ...
   ```

3. **文档字符串**
   ```python
   def verify_case(self, case: WealthCase) -> List[Dict[str, Any]]:
       """
       验证财富案例的预测结果
       
       Args:
           case: 财富案例对象
           
       Returns:
           验证结果列表，每个结果包含 year, predicted, error 等字段
       """
   ```

4. **配置管理**
   - 使用 `config/parameters.json` 存储配置
   - Controller 负责加载和传递配置
   - 避免硬编码配置值
   - 所有可调参数必须通过配置文件管理
   - 使用 `core.config_manager` 或 `core.config_schema` 加载配置

## 🔍 代码审查检查清单 (Code Review Checklist)

在提交代码前，请确认：

### 文档检查（新功能必须）
- [ ] 需求文档已创建（`docs/REQUIREMENTS_*.md`）
- [ ] 设计文档已创建（`docs/DESIGN_*.md`）
- [ ] TODO List 已创建并包含所有任务
- [ ] 文档已提交到版本控制系统

### 架构检查
- [ ] View 层只调用 Controller，不直接调用 Engine
- [ ] Controller 层封装了所有业务逻辑
- [ ] Model 层只负责数据操作，不包含业务逻辑
- [ ] 所有文件 I/O 操作在 Model 层
- [ ] 遵循 MVC 分层架构

### 配置检查
- [ ] 没有硬编码的数值（所有参数从配置文件读取）
- [ ] 配置项有合理的默认值
- [ ] 配置加载有错误处理
- [ ] 配置变更会失效相关缓存

### 算法检查（八字相关功能必须）
- [ ] 遵循核心算法总纲（`ALGORITHM_CONSTITUTION_v2.6.md`）
- [ ] 遵循核心算法内核（`CORE_ALGORITHM_KERNEL_V9.md`）
- [ ] 参考了相关算法补充文档
- [ ] 所有算法参数从配置文件读取
- [ ] 参数可通过 `FullAlgoParams` 接口调优
- [ ] 有回归验证接口

### 代码质量检查
- [ ] 错误处理在适当的层级完成
- [ ] 类型提示完整（所有公共方法）
- [ ] 文档字符串清晰（Google/NumPy 风格）
- [ ] 遵循命名规范
- [ ] 使用 `logging` 而不是 `print()`
- [ ] 没有裸露的 `except:` 语句

### 测试检查（新功能必须）
- [ ] **单元测试**: 所有新功能都有对应的单元测试
- [ ] **集成测试**: 有集成测试验证完整业务流程
- [ ] **回归测试**: 修复的 Bug 和历史案例有回归测试
- [ ] **测试覆盖**: 测试覆盖率 ≥ 80%，关键路径 = 100%
- [ ] **测试通过**: 所有测试用例通过，无失败或跳过
- [ ] **测试文档**: 测试文件有清晰的文档说明
- [ ] **测试性能**: 测试执行时间合理（单元测试 < 1秒，集成测试 < 10秒）

### 性能检查
- [ ] 使用了适当的缓存机制
- [ ] 延迟初始化（Lazy Loading）
- [ ] 批量操作优于循环单个操作

## 📚 参考文档 (Reference Documentation)

### 架构文档
- MVC 架构文档: `docs/WEALTH_VERIFICATION_MVC_ARCHITECTURE.md`
- Controller API: `docs/CONTROLLER_API.md`
- 架构总览: `docs/ARCHITECTURE.md`

### 算法规范文档（必须遵循）
- **核心算法总纲**: `docs/ALGORITHM_CONSTITUTION_v2.6.md` (最新版本)
- **核心算法内核**: `docs/CORE_ALGORITHM_KERNEL_V9.md`
- **算法补充文档**:
  - `docs/ALGORITHM_SUPPLEMENT_L2_ENERGY_CONDUCTION.md` (能量传导)
  - `docs/ALGORITHM_SUPPLEMENT_L2_SPACETIME.md` (时空)
  - `docs/ALGORITHM_SUPPLEMENT_L2_STOREHOUSE.md` (墓库)

## ⚙️ 配置化与参数管理 (Configuration & Parameters)

### 强制要求

1. **禁止硬编码**
   ```python
   # ❌ 错误：硬编码数值
   wealth_bonus = 100.0
   error_threshold = 20.0
   max_retries = 3
   
   # ✅ 正确：从配置文件读取
   from core.config_manager import get_config_manager
   config = get_config_manager()
   wealth_bonus = config.get('wealth', {}).get('bonus', 100.0)
   error_threshold = config.get('verification', {}).get('error_threshold', 20.0)
   ```

2. **配置文件结构**
   - 主配置: `config/parameters.json`
   - 默认配置: `core/config_schema.py` 中的 `DEFAULT_FULL_ALGO_PARAMS`
   - 用户配置: 通过 UI 修改后保存到 `config/parameters.json`

3. **配置加载模式**
   ```python
   # ✅ 推荐方式：使用 ConfigManager
   from core.config_manager import get_config_manager
   config_manager = get_config_manager()
   value = config_manager.get('section', 'key', default_value)
   
   # ✅ 或者：使用 config_schema
   from core.config_schema import DEFAULT_FULL_ALGO_PARAMS
   import json
   config = copy.deepcopy(DEFAULT_FULL_ALGO_PARAMS)
   # 合并用户配置
   with open('config/parameters.json', 'r') as f:
       user_config = json.load(f)
       # 深度合并
   ```

4. **配置项命名规范**
   - 使用有意义的键名
   - 使用嵌套结构组织相关配置
   - 提供默认值和文档说明
   ```json
   {
     "wealth": {
       "base_energy": 50.0,
       "strong_root_bonus": 40.0,
       "vault_bonus": 100.0,
       "clash_penalty": 150.0,
       "error_threshold": 20.0
     },
     "verification": {
       "hit_rate_threshold": 0.5,
       "max_error": 30.0
     }
   }
   ```

5. **运行时配置修改**
   - Controller 可以动态加载配置
   - 配置变更后应失效相关缓存
   - 重要配置变更应记录日志

## 🔒 代码质量约束 (Code Quality Constraints)

### 1. 类型安全
   - 所有公共方法必须有类型提示
   - 使用 `typing` 模块的类型注解
   - 避免使用 `Any`，除非必要
   ```python
   from typing import List, Dict, Optional, Union
   
   def verify_case(self, case: WealthCase) -> List[Dict[str, Union[float, str]]]:
       ...
   ```

### 2. 错误处理
   - 所有可能失败的操作必须有异常处理
   - 使用具体的异常类型，避免裸露 `except:`
   - 记录错误日志，返回用户友好的错误信息
   ```python
   try:
       result = engine.calculate_wealth_index(...)
   except ValueError as e:
       logger.error(f"Invalid input: {e}")
       return None
   except Exception as e:
       logger.exception(f"Unexpected error: {e}")
       raise
   ```

### 3. 日志记录
   - 使用 `logging` 模块，不要使用 `print()`
   - 不同级别：DEBUG, INFO, WARNING, ERROR
   - Controller 和 Model 层必须记录关键操作
   ```python
   import logging
   logger = logging.getLogger(__name__)
   logger.info("Starting verification...")
   logger.debug(f"Case data: {case}")
   ```

### 4. 文档字符串
   - 所有公共类和方法必须有文档字符串
   - 使用 Google 风格或 NumPy 风格
   - 包含参数说明、返回值说明、示例
   ```python
   def verify_case(self, case: WealthCase) -> List[Dict[str, Any]]:
       """
       验证财富案例的预测结果
       
       Args:
           case: 财富案例对象，包含八字和事件时间线
           
       Returns:
           验证结果列表，每个结果包含：
           - year: 年份
           - predicted: 预测值
           - real: 真实值
           - error: 误差
           - is_correct: 是否在误差范围内
           
       Raises:
           ValueError: 如果案例数据无效
           
       Example:
           >>> case = WealthCase(...)
           >>> results = controller.verify_case(case)
           >>> print(f"Hit rate: {sum(r['is_correct'] for r in results) / len(results)}")
       """
   ```

### 5. 性能优化
   - 使用缓存避免重复计算
   - 延迟初始化（Lazy Initialization）
   - 批量操作优于循环单个操作
   ```python
   # ✅ 使用缓存
   @lru_cache(maxsize=128)
   def expensive_calculation(self, key: str) -> float:
       ...
   
   # ✅ 延迟初始化
   @property
   def engine(self):
       if self._engine is None:
           self._engine = GraphNetworkEngine()
       return self._engine
   ```

## 🎯 特殊规则 (Special Rules)

### 财富验证功能
- 必须使用 `WealthVerificationController` 进行验证
- 案例数据通过 `WealthCaseModel` 管理
- UI 通过 `ui/pages/wealth_verification.py` 展示
- 所有财富计算参数必须从 `config/parameters.json` 读取

### 八字排盘功能
- 必须使用 `BaziController` 进行排盘
- 通过 `get_chart()`, `get_luck_cycles()` 等方法获取数据
- UI 通过 `ui/pages/prediction_dashboard.py` 展示
- 所有算法参数必须从配置文件读取

### 脚本和工具
- `scripts/` 目录下的脚本可以混合使用（向后兼容）
- 新功能必须遵循 MVC 架构
- 测试脚本可以使用直接 Engine 访问
- 脚本中的参数也应尽量从配置文件读取

## 📄 文档要求 (Documentation Requirements)

### 强制要求：所有新功能必须包含以下文档

1. **需求文档 (Requirements Document)**
   - 位置: `docs/` 目录
   - 命名: `REQUIREMENTS_<功能名>.md` 或 `REQUIREMENTS_V<版本>_<功能名>.md`
   - 内容必须包括:
     - 功能概述和目标
     - 用户故事和使用场景
     - 功能需求列表
     - 非功能需求（性能、安全等）
     - 验收标准
   
   ```markdown
   # 需求文档: <功能名>
   
   ## 1. 功能概述
   - 目标: ...
   - 背景: ...
   
   ## 2. 用户故事
   - 作为...，我希望...，以便...
   
   ## 3. 功能需求
   - [ ] FR-001: ...
   - [ ] FR-002: ...
   
   ## 4. 非功能需求
   - 性能: ...
   - 安全: ...
   
   ## 5. 验收标准
   - [ ] AC-001: ...
   ```

2. **设计文档 (Design Document)**
   - 位置: `docs/` 目录
   - 命名: `DESIGN_<功能名>.md` 或 `DESIGN_V<版本>_<功能名>.md`
   - 内容必须包括:
     - 架构设计（MVC 分层）
     - 数据模型设计
     - API 设计（Controller 接口）
     - 算法设计（如涉及）
     - 数据库/文件结构设计
     - 流程图或时序图
   
   ```markdown
   # 设计文档: <功能名>
   
   ## 1. 架构设计
   - View 层: ...
   - Controller 层: ...
   - Model 层: ...
   
   ## 2. 数据模型
   - 数据结构: ...
   - 数据流: ...
   
   ## 3. API 设计
   - Controller 方法: ...
   - 参数和返回值: ...
   
   ## 4. 算法设计
   - 核心逻辑: ...
   - 参数配置: ...
   ```

3. **TODO List (任务清单)**
   - 位置: 项目根目录或 `docs/` 目录
   - 命名: `TODO_<功能名>.md` 或使用项目的统一 TODO 管理
   - 内容必须包括:
     - 开发任务列表（按优先级）
     - 测试任务列表
     - 文档任务列表
     - 每个任务的状态（待办/进行中/已完成）
   
   ```markdown
   # TODO: <功能名>
   
   ## 开发任务
   - [ ] 任务1: ...
   - [ ] 任务2: ...
   
   ## 测试任务
   - [ ] 单元测试
   - [ ] 集成测试
   
   ## 文档任务
   - [ ] 更新 API 文档
   - [ ] 编写用户指南
   ```

### 文档审查检查清单
- [ ] 需求文档已创建并包含所有必需章节
- [ ] 设计文档已创建并包含架构设计
- [ ] TODO List 已创建并包含所有任务
- [ ] 文档已提交到版本控制系统

## 🧪 测试要求 (Testing Requirements)

### 强制要求：所有新功能必须包含测试

**核心原则**: 每个新功能单元必须同时提供单元测试、集成测试和回归测试用例。

### 1. 测试类型要求

#### 1.1 单元测试 (Unit Tests)
- **位置**: `tests/unit/` 或 `tests/test_<功能名>.py`
- **覆盖范围**: 
  - 所有公共方法
  - 所有边界条件
  - 所有错误处理路径
- **命名规范**: `test_<功能名>_<具体功能>.py` 或 `Test<ClassName>` 类
- **要求**:
  - 每个功能方法至少有一个测试用例
  - 测试用例必须独立，不依赖外部资源（使用 Mock）
  - 测试覆盖率 ≥ 80%

#### 1.2 集成测试 (Integration Tests)
- **位置**: `tests/integration/` 或 `tests/test_<功能名>_integration.py`
- **覆盖范围**:
  - Controller 与 Model 的交互
  - Controller 与 Engine 的交互
  - 完整业务流程
- **命名规范**: `test_<功能名>_integration.py` 或 `Test<ClassName>Integration`
- **要求**:
  - 测试真实的数据流
  - 验证各层之间的接口契约
  - 测试端到端场景

#### 1.3 回归测试 (Regression Tests)
- **位置**: `tests/test_<功能名>_regression.py` 或集成到现有回归测试套件
- **覆盖范围**:
  - 修复的 Bug 场景
  - 历史案例验证
  - 性能回归
- **命名规范**: `test_<功能名>_regression.py` 或 `Test<ClassName>Regression`
- **要求**:
  - 确保修复的问题不再重现
  - 验证历史案例的准确性
  - 性能指标不退化

### 2. 测试文件结构

```
tests/
├── unit/                          # 单元测试
│   ├── test_<功能名>.py          # 功能单元测试
│   └── ...
├── integration/                   # 集成测试
│   ├── test_<功能名>_integration.py
│   └── ...
├── test_<功能名>_regression.py   # 回归测试
└── conftest.py                    # pytest 配置和 fixtures
```

### 3. 测试代码规范

#### 3.1 测试类结构
```python
import unittest
from unittest.mock import Mock, patch

class TestMyFeature(unittest.TestCase):
    """测试我的功能"""
    
    def setUp(self):
        """测试前准备"""
        # 初始化测试数据
        self.test_data = {...}
    
    def tearDown(self):
        """测试后清理"""
        # 清理资源
        pass
    
    def test_basic_functionality(self):
        """测试基本功能"""
        # Arrange
        input_data = self.test_data
        
        # Act
        result = my_function(input_data)
        
        # Assert
        self.assertIsNotNone(result)
        self.assertEqual(result['status'], 'success')
        print("✅ 基本功能测试通过")
    
    def test_edge_case(self):
        """测试边界情况"""
        # 测试空输入、None、边界值等
        pass
    
    def test_error_handling(self):
        """测试错误处理"""
        with self.assertRaises(ValueError):
            my_function(invalid_input)
```

#### 3.2 测试命名规范
- 测试类: `Test<ClassName>` 或 `Test<FeatureName>`
- 测试方法: `test_<功能描述>`，使用下划线分隔
- 测试文件: `test_<功能名>.py`，使用下划线分隔

#### 3.3 测试断言
```python
# ✅ 推荐：使用具体的断言方法
self.assertEqual(actual, expected)
self.assertIsNotNone(result)
self.assertIn('key', result)
self.assertTrue(condition)
self.assertRaises(ValueError, function, args)

# ❌ 避免：使用 assert 语句（pytest 除外）
assert result == expected  # 不推荐在 unittest 中使用
```

### 4. 测试执行要求

#### 4.1 测试必须通过
- 所有测试用例必须通过才能提交代码
- 不允许跳过测试（除非有明确理由）
- 测试失败必须修复，不能注释掉

#### 4.2 测试覆盖率
- 单元测试覆盖率 ≥ 80%
- 关键路径覆盖率 = 100%
- 使用 `pytest-cov` 生成覆盖率报告

#### 4.3 测试性能
- 单元测试单个用例执行时间 < 1 秒
- 集成测试单个用例执行时间 < 10 秒
- 所有测试总执行时间 < 5 分钟

### 5. 测试检查清单

在提交代码前，必须确认：

#### 单元测试检查
- [ ] 所有新功能都有对应的单元测试
- [ ] 测试覆盖所有公共方法
- [ ] 测试覆盖边界条件和错误情况
- [ ] 测试用例独立，不依赖外部资源
- [ ] 使用 Mock 隔离外部依赖
- [ ] 测试命名清晰，描述功能

#### 集成测试检查
- [ ] 有集成测试验证完整业务流程
- [ ] 测试 Controller 与 Model 的交互
- [ ] 测试 Controller 与 Engine 的交互
- [ ] 测试端到端场景
- [ ] 验证接口契约

#### 回归测试检查
- [ ] 修复的 Bug 有回归测试
- [ ] 历史案例验证通过
- [ ] 性能指标未退化
- [ ] 相关回归测试已更新

#### 测试执行检查
- [ ] 所有测试用例通过
- [ ] 测试覆盖率达标（≥ 80%）
- [ ] 测试执行时间合理
- [ ] 测试报告已生成

### 6. 测试示例

#### 示例 1: 新功能单元测试
```python
# tests/test_new_feature.py
import unittest
from core.processors.new_feature import NewFeatureProcessor

class TestNewFeatureProcessor(unittest.TestCase):
    """测试新功能处理器"""
    
    def setUp(self):
        self.processor = NewFeatureProcessor()
    
    def test_process_basic(self):
        """测试基本处理功能"""
        result = self.processor.process({'input': 'test'})
        self.assertIsNotNone(result)
        self.assertIn('output', result)
        print("✅ 基本处理功能测试通过")
    
    def test_process_edge_case(self):
        """测试边界情况"""
        result = self.processor.process({'input': ''})
        # 验证边界情况处理
        self.assertIsNotNone(result)
    
    def test_process_error_handling(self):
        """测试错误处理"""
        with self.assertRaises(ValueError):
            self.processor.process(None)
```

#### 示例 2: 集成测试
```python
# tests/integration/test_new_feature_integration.py
import unittest
from controllers.new_feature_controller import NewFeatureController
from core.models.new_feature_model import NewFeatureModel

class TestNewFeatureIntegration(unittest.TestCase):
    """测试新功能集成"""
    
    def setUp(self):
        self.controller = NewFeatureController()
        self.model = NewFeatureModel()
    
    def test_controller_model_integration(self):
        """测试 Controller 与 Model 的集成"""
        # 测试完整的数据流
        result = self.controller.process_data({'input': 'test'})
        self.assertIsNotNone(result)
        # 验证数据已保存到 Model
        saved_data = self.model.load_data('test_id')
        self.assertIsNotNone(saved_data)
        print("✅ Controller-Model 集成测试通过")
```

#### 示例 3: 回归测试
```python
# tests/test_new_feature_regression.py
import unittest
from core.processors.new_feature import NewFeatureProcessor

class TestNewFeatureRegression(unittest.TestCase):
    """测试新功能回归"""
    
    def test_bug_fix_001(self):
        """回归测试：修复 Bug #001"""
        processor = NewFeatureProcessor()
        # 重现 Bug 场景
        result = processor.process({'input': 'bug_scenario'})
        # 验证 Bug 已修复
        self.assertNotEqual(result['status'], 'error')
        print("✅ Bug #001 回归测试通过")
    
    def test_historical_case(self):
        """回归测试：历史案例验证"""
        processor = NewFeatureProcessor()
        # 使用历史案例数据
        historical_data = load_historical_case('case_001')
        result = processor.process(historical_data)
        # 验证结果与历史一致
        self.assertEqual(result['output'], historical_data['expected_output'])
        print("✅ 历史案例验证通过")
```

### 7. 测试工具和框架

#### 推荐工具
- **单元测试框架**: `unittest` (Python 标准库) 或 `pytest`
- **Mock 框架**: `unittest.mock` 或 `pytest-mock`
- **覆盖率工具**: `pytest-cov` 或 `coverage.py`
- **性能测试**: `pytest-benchmark`

#### 运行测试
```bash
# 运行所有测试
pytest tests/ -v

# 运行特定测试文件
pytest tests/test_new_feature.py -v

# 运行并生成覆盖率报告
pytest tests/ --cov=core --cov=controllers --cov-report=html

# 运行集成测试
pytest tests/integration/ -v

# 运行回归测试
pytest tests/ -k regression -v
```

### 8. 测试文档要求

每个测试文件必须包含：
- 文件头注释说明测试目的
- 测试类和方法都有文档字符串
- 复杂测试用例有注释说明测试意图

```python
"""
新功能测试套件
================
测试新功能处理器的所有功能

测试覆盖:
1. 基本功能
2. 边界情况
3. 错误处理
4. 性能测试
"""

import unittest
...
```

---

**重要提醒**: 
- ❌ **禁止**在没有测试的情况下提交新功能代码
- ❌ **禁止**跳过或注释掉失败的测试
- ✅ **必须**在实现功能的同时编写测试
- ✅ **必须**确保所有测试通过才能提交

## 🧮 八字算法规范 (Bazi Algorithm Standards)

### 强制要求：所有算法实现必须遵循

1. **核心算法总纲 (Algorithm Constitution)**
   - **必须遵循**: `docs/ALGORITHM_CONSTITUTION_v2.6.md`
   - **核心原则**:
     - ✅ 所有参数必须可配置（禁止硬编码）
     - ✅ 所有数值必须有回归验证接口
     - ✅ 遵循物理模型（矢量场、波动力学、流体力学）
     - ✅ 使用 `FullAlgoParams` 接口暴露参数
   
2. **核心算法内核 (Algorithm Kernel)**
   - **必须遵循**: `docs/CORE_ALGORITHM_KERNEL_V9.md`
   - **核心定义**:
     - 阴阳 = 自旋 (Spin)
     - 五行 = 矢量场 (Vector Fields)
     - 天干 = 波形态 (Waveforms)
     - 地支 = 场域环境 (Field Environments)

3. **算法补充文档 (Algorithm Supplements)**
   - **能量传导**: `docs/ALGORITHM_SUPPLEMENT_L2_ENERGY_CONDUCTION.md`
     - 垂直作用与透干
     - 通根机制
     - 自坐加成
   
   - **时空**: `docs/ALGORITHM_SUPPLEMENT_L2_SPACETIME.md`
     - 大运流年机制
     - 时空修正
   
   - **墓库**: `docs/ALGORITHM_SUPPLEMENT_L2_STOREHOUSE.md`
     - 墓库拓扑学
     - 量子隧穿机制

4. **算法实现检查清单**
   - [ ] 所有参数从配置文件读取（`config/parameters.json`）
   - [ ] 遵循物理模型定义（矢量场、波形态等）
   - [ ] 实现符合算法总纲的规范
   - [ ] 参考了相关补充文档的机制
   - [ ] 参数可通过 `FullAlgoParams` 接口调优
   - [ ] 有回归验证接口

5. **算法修改流程**
   - 修改算法前，必须先更新相关文档
   - 重大算法变更需要更新算法总纲
   - 新增机制需要创建或更新补充文档
   - 所有算法变更必须通过回归测试

---

**最后更新**: 2025-01-XX  
**版本**: 1.1.0  
**维护者**: Bazi Predict Team

